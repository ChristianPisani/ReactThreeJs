/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 .\\CornFieldArea.glb
*/

import React, {
    useEffect,
    useRef,
    useState
} from 'react'
import {
    Box,
    useGLTF
} from '@react-three/drei'
import {
    MeshSurfaceSampler
} from "three/addons/math/MeshSurfaceSampler.js";
import * as THREE
    from "three";
import {
    CornPlant
} from "./CornPlant.jsx";
import {
    Corn1
} from "./Corn1.jsx";
import {
    CornPlantSimple
} from "./CornPlantSimple.jsx";
import {
    getTiledPos
} from "../util/utils.js";
import {
    useBox,
    useCylinder,
    useSphere
} from "@react-three/cannon";
import {
    useFrame
} from "@react-three/fiber";
import {
    Vector3
} from "three";
import {
    CornParticles
} from "./CornParticles.jsx";
import {
    CornDestroyed
} from "./CornDestroyed.jsx";

export function CornFieldArea(props) {
    const {
        nodes,
        materials
    } = useGLTF('/CornFieldArea.glb')

    const [updateToggle, setUpdateToggle] = useState(false); 
    const cornField = useRef([])
    let tiledPlayerPos = useRef([])

    const {playerPosRef} = props;

    const mesh = nodes.Cube001;

    const tileSize = 5;
    const tileOffset = 16; // Adjust negative values in grid

    const extend = 1;

    useEffect(() => {
        // Create a sampler for a Mesh surface.
        const sampler = new MeshSurfaceSampler(mesh)
            .setWeightAttribute('color')
            .build();

        const _position = new THREE.Vector3();

        const newPositions = [];

        for (let i = 0; i < 5000; i++) {
            sampler.sample(_position);

            const tiledPos = getTiledPos(_position.toArray(), tileSize);
            tiledPos[0] += tileOffset;
            tiledPos[2] += tileOffset;

            const randomScale = 1;

            if (!newPositions[tiledPos[0]]) {
                newPositions[tiledPos[0]] = [];
            }

            if (!newPositions[tiledPos[0]][tiledPos[2]]) {
                newPositions[tiledPos[0]][tiledPos[2]] = [];
            }

            newPositions[tiledPos[0]][tiledPos[2]].push({
                position: {
                    x: _position.x,
                    y: _position.y,
                    z: _position.z
                },
                rotation: {
                    x: Math.random() * 0.5,
                    y: Math.random() * 360,
                    z: Math.random() * 0.5
                },
                scale: {
                    x: randomScale,
                    y: randomScale,
                    z: randomScale
                },
                variation: Math.round(Math.random() * 2) + 1
            });
        }

        cornField.current = newPositions;
    }, [nodes])

    useFrame(() => {
        if (!playerPosRef) return;

        let anyDestroyed = false;
        for (let x = 0; x < cornField.current.length; x++) {
            for (let y = 0; y < cornField.current[x]?.length; y++) {
                if (withinBounds(tiledPlayerPos.current, x, y)) {
                    for (let i = 0; i < cornField.current[x][y]?.length; i++) {
                        const plant = cornField.current[x][y][i];
                        if(!plant?.position || plant.destroyed) continue;
                        
                        const playerPosVector = new Vector3(playerPosRef.current[0], 0, playerPosRef.current[2]);
                        const plantPositionVector = new Vector3(plant.position.x, 0, plant.position.z);
                        
                        const distance = playerPosVector.distanceTo(plantPositionVector);
                        if (distance < 3) {
                            anyDestroyed = true;
                            cornField.current[x][y][i].destroyed = true;
                        }
                    }
                }
            }
        }
        if(anyDestroyed) {
            setUpdateToggle(!updateToggle);
        }

        const newTiledPos = getTiledPos([playerPosRef.current[0], 0, playerPosRef.current[2]], tileSize);

        if (newTiledPos[0] === tiledPlayerPos[0] && newTiledPos[2] === tiledPlayerPos[2]) return;

        tiledPlayerPos.current = [newTiledPos[0] + tileOffset, 0, newTiledPos[2] + tileOffset];
    })

    const withinBounds = (pos, x, y) => {
        return pos[0] >= (x - extend) && pos[0] <= (x + extend)
            && pos[2] >= (y - extend) && pos[2] <= (y + extend);
    }

    return (
        <group {...props}
               dispose={null}>
            <CornPlantSimple
                plants={cornField.current.flatMap(x => x.flatMap(y => y))}></CornPlantSimple>

            {cornField.current[0] && cornField.current.map((column, columnIndex) => {
                return column.map((row, rowIndex) => {
                    return row.map((tile, index) => (
                        <>
                            {tile.destroyed &&
                                <>
                                    <CornParticles
                                        key={index + "_box"}
                                        position={[tile.position.x, tile.position.y, tile.position.z]}
                                        velocity={[0,0,0]}
                                        scale={[2, 10, 2]}></CornParticles>
                                    <CornDestroyed
                                        position={[tile.position.x, tile.position.y, tile.position.z]}
                                        scale={[tile.scale.x, tile.scale.y, tile.scale.z]}
                                        rotation={[tile.rotation.x, tile.rotation.y, tile.rotation.z]}></CornDestroyed>
                                </>
                            }
                            {withinBounds(tiledPlayerPos.current, columnIndex, rowIndex) && <></>
                                /*<Collider
                                    key={"collider" + index + tile.position.x + tile.position.z}
                                    pos={tile.position}
                                    onCollide={() => {
                                        tile.destroyed = true;
                                        setCornField([...cornField]);
                                        console.log("Collide")
                                    }}></Collider>*/}
                        </>
                    ))
                })
            })}
        </group>
    )
}

const Collider = (props) => {
    const {
        pos,
        onCollide
    } = props;

    if (!pos) return;

    const [ref, api] = useSphere(() => ({
        position: [pos.x, pos.y + 1, pos.z],
        args: [1, 10, 1],
        type: "Static",
        onCollide: (e) => {
            onCollide();
        },
        collisionResponse: 0,
        collisionFilterGroup: 80,
        collisionFilterMask: 1,
        isTrigger: true
    }));

    return (
        <></>
    )
}

useGLTF.preload('/CornFieldArea.glb')
