/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 .\\CornFieldArea.glb
*/

import React, {
    useEffect,
    useRef,
    useState
} from 'react'
import {
    Box,
    useGLTF
} from '@react-three/drei'
import {
    MeshSurfaceSampler
} from "three/addons/math/MeshSurfaceSampler.js";
import * as THREE
    from "three";
import {
    CornPlant
} from "./CornPlant.jsx";
import {
    Corn1
} from "./Corn1.jsx";
import {
    CornPlantSimple
} from "./CornPlantSimple.jsx";
import {
    getTiledPos
} from "../util/utils.js";
import {
    useBox,
    useCylinder,
    useSphere
} from "@react-three/cannon";
import {
    useFrame
} from "@react-three/fiber";
import {
    Vector3
} from "three";
import {
    CornParticles
} from "./CornParticles.jsx";
import {
    CornShrub
} from "./CornShrub.jsx";

export function CornFieldArea(props) {
    const [updateToggle, setUpdateToggle] = useState(false);
    const cornField = useRef([])
    let tiledPlayerPos = useRef([])

    const {
        playerPosRef,
        mesh
    } = props;

    const tileSize = 5;
    const tileOffset = 0; // Adjust negative values in grid

    const extend = 1;

    useEffect(() => {
        if (!mesh || mesh.type != 'Mesh') return;
        // Create a sampler for a Mesh surface.
        const sampler = new MeshSurfaceSampler(mesh)
            .setWeightAttribute('color')
            .build();

        const _position = new THREE.Vector3();

        const newPositions = {};

        for (let i = 0; i < 600; i++) {
            sampler.sample(_position);

            const tiledPos = getTiledPos(_position.toArray(), tileSize);
            tiledPos[0] += tileOffset;
            tiledPos[2] += tileOffset;

            const randomScale = 1;

            if (!newPositions[tiledPos[0]]) {
                newPositions[tiledPos[0]] = {};
            }

            if (!newPositions[tiledPos[0]][tiledPos[2]]) {
                newPositions[tiledPos[0]][tiledPos[2]] = [];
            }

            newPositions[tiledPos[0]][tiledPos[2]].push({
                position: {
                    x: _position.x,
                    y: _position.y,
                    z: _position.z
                },
                rotation: {
                    x: Math.random() * 0.5,
                    y: Math.random() * 360,
                    z: Math.random() * 0.5
                },
                scale: {
                    x: randomScale,
                    y: randomScale,
                    z: randomScale
                },
                variation: Math.round(Math.random() * 2) + 1
            });
        }

        cornField.current = newPositions;
    }, [mesh])

    useFrame(() => {
        if (!playerPosRef) return;

        let anyDestroyed = false;

        const xKeys = Object.keys(cornField.current)
            .map(x => Number(x))
            .sort();

        for (let x = 0; x < xKeys.length; x++) {

            const yKeys = Object.keys(cornField.current[xKeys[x]])
                .map(x => Number(x))
                .sort();

            for (let y = 0; y < yKeys.length; y++) {
                if (withinBounds(tiledPlayerPos.current, xKeys[x], yKeys[y])) {
                    for (let i = 0; i < cornField.current[xKeys[x]][yKeys[y]]?.length; i++) {
                        const plant = cornField.current[xKeys[x]][yKeys[y]][i];
                        if (!plant?.position || plant.destroyed) continue;

                        const playerPosVector = new Vector3(playerPosRef.current[0], 0, playerPosRef.current[2]);
                        const plantPositionVector = new Vector3(plant.position.x, 0, plant.position.z);

                        const distance = playerPosVector.distanceTo(plantPositionVector);
                        if (distance < 3) {
                            anyDestroyed = true;
                            cornField.current[xKeys[x]][yKeys[y]][i].destroyed = true;
                        }
                    }
                }
            }
        }
        if (anyDestroyed) {
            setUpdateToggle(!updateToggle);
        }

        const newTiledPos = getTiledPos([playerPosRef.current[0], 0, playerPosRef.current[2]], tileSize);

        if (newTiledPos[0] === tiledPlayerPos[0] && newTiledPos[2] === tiledPlayerPos[2]) return;

        tiledPlayerPos.current = [newTiledPos[0] + tileOffset, 0, newTiledPos[2] + tileOffset];
    })

    const withinBounds = (pos, x, y) => {
        return pos[0] >= (x - extend) && pos[0] <= (x + extend)
            && pos[2] >= (y - extend) && pos[2] <= (y + extend);
    }

    const cornParticles = [];
    const cornShrubs = [];

    const xKeys = Object.keys(cornField.current)
        .map(x => Number(x))
        .sort();

    for (let x = 0; x < xKeys.length; x++) {
        const yKeys = Object.keys(cornField.current[xKeys[x]])
            .map(x => Number(x))
            .sort();

        for (let y = 0; y < yKeys.length; y++) {
            for (let i = 0; i < cornField.current[xKeys[x]][yKeys[y]]?.length; i++) {
                const tile = cornField.current[xKeys[x]][yKeys[y]][i];

                if (tile.destroyed) {
                    cornParticles.push(
                        <CornParticles
                            key={`${x}-${y}-${i}-particle`}
                            position={[tile.position.x, tile.position.y, tile.position.z]}
                            velocity={[0, 0, 0]}
                            scale={[2, 10, 2]}></CornParticles>);

                    /*cornShrubs.push(
                        <CornShrub
                            key={`${x}-${y}-${i}-shrub`}
                            position={[tile.position.x, tile.position.y, tile.position.z]}
                            scale={[tile.scale.x, tile.scale.y, tile.scale.z]}
                            rotation={[tile.rotation.x, tile.rotation.y, tile.rotation.z]}></CornShrub>
                    );*/
                }
            }
        }
    }
    
    return (
        <group {...props}
               dispose={null}>
            <CornPlantSimple
                plants={Object.keys(cornField.current).flatMap(x => Object.keys(cornField.current[x]).flatMap(y => cornField.current[x][y]))}></CornPlantSimple>

            {cornParticles}
            {cornShrubs}
        </group>
    )
}